# -*- coding: UTF-8 -*-import structimport timeimport aclfrom process import process_imageimport numpy as npCLASSES = ("daisy", "roses", "sunflowers", "tulips")ACL_MEM_MALLOC_HUGE_FIRST = 0ACL_MEMCPY_HOST_TO_DEVICE = 1ACL_MEMCPY_DEVICE_TO_HOST = 2NPY_BYTE = 1class ACLEngine(object):    def __init__(self, model_path, device_id=0):        self.device_id = device_id        self.context = None        self.model_id = None        self.model_desc = None        self.load_input_dataset, self.load_output_dataset = None, None        self.input_data, self.output_data = None, None        # --------------- pyACL初始化 ---------------        print('Start init resource')        self._init_resource()        self._load_model(model_path)        self._prepare_inputs()    def inference(self, img_path):        """ 模型推理及后处理模块 """        # 1.读取并预处理图片        img = process_image(img_path)        # 2.准备模型推理的输入数据，运行模式默认为运行模式为ACL_HOST，当前实例代码中模型只有一个输入。        bytes_data = img.tobytes()        np_ptr = acl.util.bytes_to_ptr(bytes_data)        start_time = time.time()        # 将图片数据从Host传输到Device。        ret = acl.rt.memcpy(self.input_data[0]["buffer"], self.input_data[0]["size"], np_ptr,                            self.input_data[0]["size"], ACL_MEMCPY_HOST_TO_DEVICE)        # 3.执行模型推理。        # self.model_id表示模型ID，在模型加载成功后，会返回标识模型的ID。        ret = acl.mdl.execute(self.model_id, self.load_input_dataset, self.load_output_dataset)        # 4.处理模型推理的输出数据，输出置信度的类别编号。        inference_result = []        for i, item in enumerate(self.output_data):            buffer_host, ret = acl.rt.malloc_host(self.output_data[i]["size"])            # 将推理输出数据从Device传输到Host。            ret = acl.rt.memcpy(buffer_host, self.output_data[i]["size"], self.output_data[i]["buffer"],                                self.output_data[i]["size"], ACL_MEMCPY_DEVICE_TO_HOST)            bytes_out = acl.util.ptr_to_bytes(buffer_host, self.output_data[i]["size"])            data = np.frombuffer(bytes_out, dtype=np.byte)            inference_result.append(data)        tuple_st = struct.unpack("4f", bytearray(inference_result[0]))        vals = np.array(tuple_st).flatten()        top_k = vals.argsort()[-1:-6:-1]        print("\n======== inference results: =============")        for i, j in enumerate(top_k):            print("top %d: class:[%s]: probability:[%f]" % (i, CLASSES[j], vals[j]))        end_time = time.time()        print('inference cost time: {:.1f}ms\n'.format((end_time-start_time)*1000))    def release_resource(self):        """ 资源释放模块 """        self._unload_model()        self._unload_picture()        self._destroy_resource()        print('Resource destroyed successfully')    def _init_resource(self):        # pyACL初始化        ret = acl.init()        # 运行管理资源申请        # 指定运算的Device。        self.device_id = 0        ret = acl.rt.set_device(self.device_id)        # 显式创建一个Context，用于管理Stream对象。        self.context, ret = acl.rt.create_context(self.device_id)    def _load_model(self, model_path):        # 加载离线模型文件，返回标识模型的ID。        self.model_id, ret = acl.mdl.load_from_file(model_path)        # 根据加载成功的模型的ID，获取该模型的描述信息。        self.model_desc = acl.mdl.create_desc()        ret = acl.mdl.get_desc(self.model_desc, self.model_id)    def _prepare_inputs(self):        # 1.准备模型推理的输入数据集。        # 创建aclmdlDataset类型的数据，描述模型推理的输入。        self.load_input_dataset = acl.mdl.create_dataset()        # 获取模型输入的数量。        input_size = acl.mdl.get_num_inputs(self.model_desc)        self.input_data = []        # 循环为每个输入申请内存，并将每个输入添加到aclmdlDataset类型的数据中。        for i in range(input_size):            buffer_size = acl.mdl.get_input_size_by_index(self.model_desc, i)            # 申请输入内存。            buffer, ret = acl.rt.malloc(buffer_size, ACL_MEM_MALLOC_HUGE_FIRST)            data = acl.create_data_buffer(buffer, buffer_size)            _, ret = acl.mdl.add_dataset_buffer(self.load_input_dataset, data)            self.input_data.append({"buffer": buffer, "size": buffer_size})        # 2.准备模型推理的输出数据集。        # 创建aclmdlDataset类型的数据，描述模型推理的输出。        self.load_output_dataset = acl.mdl.create_dataset()        # 获取模型输出的数量。        output_size = acl.mdl.get_num_outputs(self.model_desc)        self.output_data = []        # 循环为每个输出申请内存，并将每个输出添加到aclmdlDataset类型的数据中。        for i in range(output_size):            buffer_size = acl.mdl.get_output_size_by_index(self.model_desc, i)            # 申请输出内存。            buffer, ret = acl.rt.malloc(buffer_size, ACL_MEM_MALLOC_HUGE_FIRST)            data = acl.create_data_buffer(buffer, buffer_size)            _, ret = acl.mdl.add_dataset_buffer(self.load_output_dataset, data)            self.output_data.append({"buffer": buffer, "size": buffer_size})    def _unload_model(self):        # 卸载模型。        ret = acl.mdl.unload(self.model_id)        # 释放模型描述信息。        if self.model_desc:            ret = acl.mdl.destroy_desc(self.model_desc)            self.model_desc = None        # 释放Context。        if self.context:            ret = acl.rt.destroy_context(self.context)            self.context = None    def _unload_picture(self):        # 释放输出资源，包括数据结构和内存。        while self.output_data:            item = self.output_data.pop()            ret = acl.rt.free(item["buffer"])        output_number = acl.mdl.get_dataset_num_buffers(self.load_output_dataset)        for i in range(output_number):            data_buf = acl.mdl.get_dataset_buffer(self.load_output_dataset, i)            if data_buf:                ret = acl.destroy_data_buffer(data_buf)        ret = acl.mdl.destroy_dataset(self.load_output_dataset)    def _destroy_resource(self):        # 释放Device。        ret = acl.rt.reset_device(self.device_id)        # pyACL去初始化。        ret = acl.finalize()if __name__ == '__main__':    engine = ACLEngine('./model/vgg16.om')    # engine = ACLEngine('./model/vgg16_fp32.om')    engine.inference('./data/daisy_demo.jpg')    engine.inference('./data/roses_demo.jpg')    engine.inference('./data/sunflowers_demo.jpg')    engine.inference('./data/tulips_demo.jpg')    engine.release_resource()